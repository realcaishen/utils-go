// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/realcaishen/utils-go/dal/model"
)

func newTChainInfo(db *gorm.DB, opts ...gen.DOOption) tChainInfo {
	_tChainInfo := tChainInfo{}

	_tChainInfo.tChainInfoDo.UseDB(db, opts...)
	_tChainInfo.tChainInfoDo.UseModel(&model.TChainInfo{})

	tableName := _tChainInfo.tChainInfoDo.TableName()
	_tChainInfo.ALL = field.NewAsterisk(tableName)
	_tChainInfo.ID = field.NewInt64(tableName, "id")
	_tChainInfo.Chainid = field.NewString(tableName, "chainid")
	_tChainInfo.RealChainid = field.NewString(tableName, "real_chainid")
	_tChainInfo.Name = field.NewString(tableName, "name")
	_tChainInfo.UpdateTimestamp = field.NewTime(tableName, "update_timestamp")
	_tChainInfo.InsertTimestamp = field.NewTime(tableName, "insert_timestamp")
	_tChainInfo.AliasName = field.NewString(tableName, "alias_name")
	_tChainInfo.Backend = field.NewInt32(tableName, "backend")
	_tChainInfo.Eip1559 = field.NewBool(tableName, "eip1559")
	_tChainInfo.NetworkCode = field.NewInt32(tableName, "network_code")
	_tChainInfo.BlockInterval = field.NewInt32(tableName, "block_interval")
	_tChainInfo.Timeout = field.NewInt32(tableName, "timeout")
	_tChainInfo.Icon = field.NewString(tableName, "icon")
	_tChainInfo.RPCEndPoint = field.NewString(tableName, "rpc_end_point")
	_tChainInfo.ExplorerURL = field.NewString(tableName, "explorer_url")
	_tChainInfo.GasTokenName = field.NewString(tableName, "gas_token_name")
	_tChainInfo.GasTokenAddress = field.NewString(tableName, "gas_token_address")
	_tChainInfo.GasTokenDecimal = field.NewInt32(tableName, "gas_token_decimal")
	_tChainInfo.GasTokenIcon = field.NewString(tableName, "gas_token_icon")
	_tChainInfo.TransferNativeGas = field.NewInt32(tableName, "transfer_native_gas")
	_tChainInfo.TransferErc20Gas = field.NewInt32(tableName, "transfer_erc20_gas")
	_tChainInfo.DepositGas = field.NewInt32(tableName, "deposit_gas")
	_tChainInfo.WithdrawGas = field.NewInt32(tableName, "withdraw_gas")
	_tChainInfo.Layer1 = field.NewString(tableName, "layer1")
	_tChainInfo.Mainnet = field.NewString(tableName, "mainnet")
	_tChainInfo.TransferContractAddress = field.NewString(tableName, "transfer_contract_address")
	_tChainInfo.Disabled = field.NewBool(tableName, "disabled")
	_tChainInfo.IsTestnet = field.NewBool(tableName, "is_testnet")
	_tChainInfo.OrderWeight = field.NewInt32(tableName, "order_weight")
	_tChainInfo.DepositContractAddress = field.NewString(tableName, "deposit_contract_address")
	_tChainInfo.OfficialRPC = field.NewString(tableName, "official_rpc")
	_tChainInfo.OfficialBridge = field.NewString(tableName, "official_bridge")
	_tChainInfo.MevRPCURL = field.NewString(tableName, "mev_rpc_url")

	_tChainInfo.fillFieldMap()

	return _tChainInfo
}

type tChainInfo struct {
	tChainInfoDo tChainInfoDo

	ALL                     field.Asterisk
	ID                      field.Int64
	Chainid                 field.String
	RealChainid             field.String
	Name                    field.String
	UpdateTimestamp         field.Time
	InsertTimestamp         field.Time
	AliasName               field.String
	Backend                 field.Int32
	Eip1559                 field.Bool
	NetworkCode             field.Int32
	BlockInterval           field.Int32
	Timeout                 field.Int32
	Icon                    field.String
	RPCEndPoint             field.String
	ExplorerURL             field.String
	GasTokenName            field.String
	GasTokenAddress         field.String
	GasTokenDecimal         field.Int32
	GasTokenIcon            field.String
	TransferNativeGas       field.Int32
	TransferErc20Gas        field.Int32
	DepositGas              field.Int32
	WithdrawGas             field.Int32
	Layer1                  field.String
	Mainnet                 field.String
	TransferContractAddress field.String
	Disabled                field.Bool
	IsTestnet               field.Bool
	OrderWeight             field.Int32
	DepositContractAddress  field.String
	OfficialRPC             field.String
	OfficialBridge          field.String
	MevRPCURL               field.String

	fieldMap map[string]field.Expr
}

func (t tChainInfo) Table(newTableName string) *tChainInfo {
	t.tChainInfoDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tChainInfo) As(alias string) *tChainInfo {
	t.tChainInfoDo.DO = *(t.tChainInfoDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tChainInfo) updateTableName(table string) *tChainInfo {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.Chainid = field.NewString(table, "chainid")
	t.RealChainid = field.NewString(table, "real_chainid")
	t.Name = field.NewString(table, "name")
	t.UpdateTimestamp = field.NewTime(table, "update_timestamp")
	t.InsertTimestamp = field.NewTime(table, "insert_timestamp")
	t.AliasName = field.NewString(table, "alias_name")
	t.Backend = field.NewInt32(table, "backend")
	t.Eip1559 = field.NewBool(table, "eip1559")
	t.NetworkCode = field.NewInt32(table, "network_code")
	t.BlockInterval = field.NewInt32(table, "block_interval")
	t.Timeout = field.NewInt32(table, "timeout")
	t.Icon = field.NewString(table, "icon")
	t.RPCEndPoint = field.NewString(table, "rpc_end_point")
	t.ExplorerURL = field.NewString(table, "explorer_url")
	t.GasTokenName = field.NewString(table, "gas_token_name")
	t.GasTokenAddress = field.NewString(table, "gas_token_address")
	t.GasTokenDecimal = field.NewInt32(table, "gas_token_decimal")
	t.GasTokenIcon = field.NewString(table, "gas_token_icon")
	t.TransferNativeGas = field.NewInt32(table, "transfer_native_gas")
	t.TransferErc20Gas = field.NewInt32(table, "transfer_erc20_gas")
	t.DepositGas = field.NewInt32(table, "deposit_gas")
	t.WithdrawGas = field.NewInt32(table, "withdraw_gas")
	t.Layer1 = field.NewString(table, "layer1")
	t.Mainnet = field.NewString(table, "mainnet")
	t.TransferContractAddress = field.NewString(table, "transfer_contract_address")
	t.Disabled = field.NewBool(table, "disabled")
	t.IsTestnet = field.NewBool(table, "is_testnet")
	t.OrderWeight = field.NewInt32(table, "order_weight")
	t.DepositContractAddress = field.NewString(table, "deposit_contract_address")
	t.OfficialRPC = field.NewString(table, "official_rpc")
	t.OfficialBridge = field.NewString(table, "official_bridge")
	t.MevRPCURL = field.NewString(table, "mev_rpc_url")

	t.fillFieldMap()

	return t
}

func (t *tChainInfo) WithContext(ctx context.Context) ITChainInfoDo {
	return t.tChainInfoDo.WithContext(ctx)
}

func (t tChainInfo) TableName() string { return t.tChainInfoDo.TableName() }

func (t tChainInfo) Alias() string { return t.tChainInfoDo.Alias() }

func (t tChainInfo) Columns(cols ...field.Expr) gen.Columns { return t.tChainInfoDo.Columns(cols...) }

func (t *tChainInfo) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tChainInfo) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 33)
	t.fieldMap["id"] = t.ID
	t.fieldMap["chainid"] = t.Chainid
	t.fieldMap["real_chainid"] = t.RealChainid
	t.fieldMap["name"] = t.Name
	t.fieldMap["update_timestamp"] = t.UpdateTimestamp
	t.fieldMap["insert_timestamp"] = t.InsertTimestamp
	t.fieldMap["alias_name"] = t.AliasName
	t.fieldMap["backend"] = t.Backend
	t.fieldMap["eip1559"] = t.Eip1559
	t.fieldMap["network_code"] = t.NetworkCode
	t.fieldMap["block_interval"] = t.BlockInterval
	t.fieldMap["timeout"] = t.Timeout
	t.fieldMap["icon"] = t.Icon
	t.fieldMap["rpc_end_point"] = t.RPCEndPoint
	t.fieldMap["explorer_url"] = t.ExplorerURL
	t.fieldMap["gas_token_name"] = t.GasTokenName
	t.fieldMap["gas_token_address"] = t.GasTokenAddress
	t.fieldMap["gas_token_decimal"] = t.GasTokenDecimal
	t.fieldMap["gas_token_icon"] = t.GasTokenIcon
	t.fieldMap["transfer_native_gas"] = t.TransferNativeGas
	t.fieldMap["transfer_erc20_gas"] = t.TransferErc20Gas
	t.fieldMap["deposit_gas"] = t.DepositGas
	t.fieldMap["withdraw_gas"] = t.WithdrawGas
	t.fieldMap["layer1"] = t.Layer1
	t.fieldMap["mainnet"] = t.Mainnet
	t.fieldMap["transfer_contract_address"] = t.TransferContractAddress
	t.fieldMap["disabled"] = t.Disabled
	t.fieldMap["is_testnet"] = t.IsTestnet
	t.fieldMap["order_weight"] = t.OrderWeight
	t.fieldMap["deposit_contract_address"] = t.DepositContractAddress
	t.fieldMap["official_rpc"] = t.OfficialRPC
	t.fieldMap["official_bridge"] = t.OfficialBridge
	t.fieldMap["mev_rpc_url"] = t.MevRPCURL
}

func (t tChainInfo) clone(db *gorm.DB) tChainInfo {
	t.tChainInfoDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tChainInfo) replaceDB(db *gorm.DB) tChainInfo {
	t.tChainInfoDo.ReplaceDB(db)
	return t
}

type tChainInfoDo struct{ gen.DO }

type ITChainInfoDo interface {
	gen.SubQuery
	Debug() ITChainInfoDo
	WithContext(ctx context.Context) ITChainInfoDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITChainInfoDo
	WriteDB() ITChainInfoDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITChainInfoDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITChainInfoDo
	Not(conds ...gen.Condition) ITChainInfoDo
	Or(conds ...gen.Condition) ITChainInfoDo
	Select(conds ...field.Expr) ITChainInfoDo
	Where(conds ...gen.Condition) ITChainInfoDo
	Order(conds ...field.Expr) ITChainInfoDo
	Distinct(cols ...field.Expr) ITChainInfoDo
	Omit(cols ...field.Expr) ITChainInfoDo
	Join(table schema.Tabler, on ...field.Expr) ITChainInfoDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITChainInfoDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITChainInfoDo
	Group(cols ...field.Expr) ITChainInfoDo
	Having(conds ...gen.Condition) ITChainInfoDo
	Limit(limit int) ITChainInfoDo
	Offset(offset int) ITChainInfoDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITChainInfoDo
	Unscoped() ITChainInfoDo
	Create(values ...*model.TChainInfo) error
	CreateInBatches(values []*model.TChainInfo, batchSize int) error
	Save(values ...*model.TChainInfo) error
	First() (*model.TChainInfo, error)
	Take() (*model.TChainInfo, error)
	Last() (*model.TChainInfo, error)
	Find() ([]*model.TChainInfo, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TChainInfo, err error)
	FindInBatches(result *[]*model.TChainInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TChainInfo) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITChainInfoDo
	Assign(attrs ...field.AssignExpr) ITChainInfoDo
	Joins(fields ...field.RelationField) ITChainInfoDo
	Preload(fields ...field.RelationField) ITChainInfoDo
	FirstOrInit() (*model.TChainInfo, error)
	FirstOrCreate() (*model.TChainInfo, error)
	FindByPage(offset int, limit int) (result []*model.TChainInfo, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITChainInfoDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tChainInfoDo) Debug() ITChainInfoDo {
	return t.withDO(t.DO.Debug())
}

func (t tChainInfoDo) WithContext(ctx context.Context) ITChainInfoDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tChainInfoDo) ReadDB() ITChainInfoDo {
	return t.Clauses(dbresolver.Read)
}

func (t tChainInfoDo) WriteDB() ITChainInfoDo {
	return t.Clauses(dbresolver.Write)
}

func (t tChainInfoDo) Session(config *gorm.Session) ITChainInfoDo {
	return t.withDO(t.DO.Session(config))
}

func (t tChainInfoDo) Clauses(conds ...clause.Expression) ITChainInfoDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tChainInfoDo) Returning(value interface{}, columns ...string) ITChainInfoDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tChainInfoDo) Not(conds ...gen.Condition) ITChainInfoDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tChainInfoDo) Or(conds ...gen.Condition) ITChainInfoDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tChainInfoDo) Select(conds ...field.Expr) ITChainInfoDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tChainInfoDo) Where(conds ...gen.Condition) ITChainInfoDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tChainInfoDo) Order(conds ...field.Expr) ITChainInfoDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tChainInfoDo) Distinct(cols ...field.Expr) ITChainInfoDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tChainInfoDo) Omit(cols ...field.Expr) ITChainInfoDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tChainInfoDo) Join(table schema.Tabler, on ...field.Expr) ITChainInfoDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tChainInfoDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITChainInfoDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tChainInfoDo) RightJoin(table schema.Tabler, on ...field.Expr) ITChainInfoDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tChainInfoDo) Group(cols ...field.Expr) ITChainInfoDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tChainInfoDo) Having(conds ...gen.Condition) ITChainInfoDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tChainInfoDo) Limit(limit int) ITChainInfoDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tChainInfoDo) Offset(offset int) ITChainInfoDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tChainInfoDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITChainInfoDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tChainInfoDo) Unscoped() ITChainInfoDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tChainInfoDo) Create(values ...*model.TChainInfo) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tChainInfoDo) CreateInBatches(values []*model.TChainInfo, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tChainInfoDo) Save(values ...*model.TChainInfo) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tChainInfoDo) First() (*model.TChainInfo, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TChainInfo), nil
	}
}

func (t tChainInfoDo) Take() (*model.TChainInfo, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TChainInfo), nil
	}
}

func (t tChainInfoDo) Last() (*model.TChainInfo, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TChainInfo), nil
	}
}

func (t tChainInfoDo) Find() ([]*model.TChainInfo, error) {
	result, err := t.DO.Find()
	return result.([]*model.TChainInfo), err
}

func (t tChainInfoDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TChainInfo, err error) {
	buf := make([]*model.TChainInfo, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tChainInfoDo) FindInBatches(result *[]*model.TChainInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tChainInfoDo) Attrs(attrs ...field.AssignExpr) ITChainInfoDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tChainInfoDo) Assign(attrs ...field.AssignExpr) ITChainInfoDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tChainInfoDo) Joins(fields ...field.RelationField) ITChainInfoDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tChainInfoDo) Preload(fields ...field.RelationField) ITChainInfoDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tChainInfoDo) FirstOrInit() (*model.TChainInfo, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TChainInfo), nil
	}
}

func (t tChainInfoDo) FirstOrCreate() (*model.TChainInfo, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TChainInfo), nil
	}
}

func (t tChainInfoDo) FindByPage(offset int, limit int) (result []*model.TChainInfo, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tChainInfoDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tChainInfoDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tChainInfoDo) Delete(models ...*model.TChainInfo) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tChainInfoDo) withDO(do gen.Dao) *tChainInfoDo {
	t.DO = *do.(*gen.DO)
	return t
}
